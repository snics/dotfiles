# =============================================================================
# Kubernetes Comprehensive Test File
# This file contains various K8s resources for testing LSP and Tree-sitter
# =============================================================================

---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/version: "1.0.0"
    environment: development
  annotations:
    description: "Test namespace for LSP and Tree-sitter testing"
    created-by: "nico"

---
# ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: config
data:
  # Application configuration
  app.properties: |
    server.port=8080
    logging.level=INFO
    database.url=jdbc:postgresql://db:5432/testdb
    cache.enabled=true
    cache.ttl=3600
  
  # Environment specific settings
  env.properties: |
    NODE_ENV=development
    DEBUG=true
    API_VERSION=v1
  
  # Feature flags
  features.json: |
    {
      "newUI": true,
      "betaFeatures": false,
      "analytics": true
    }

---
# Secret
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: secrets
type: Opaque
data:
  # Base64 encoded secrets
  database-password: cGFzc3dvcmQxMjM=  # password123
  api-key: YWJjZGVmZ2hpams=            # abcdefghijk
  jwt-secret: bXlqd3RzZWNyZXQ=         # myjwtsecret
stringData:
  # Plain text secrets (will be base64 encoded automatically)
  database-username: "testuser"
  redis-password: "redispass456"

---
# PersistentVolume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: test-pv
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: storage
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
    - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  storageClassName: fast-ssd
  hostPath:
    path: /data/test-pv

---
# PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-pvc
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: storage
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: fast-ssd

---
# Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-service-account
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: rbac
  annotations:
    description: "Service account for test application"

---
# Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: test-role
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: rbac
rules:
  - apiGroups: [""]
    resources: ["pods", "services", "configmaps"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets"]
    verbs: ["get", "list", "watch", "create", "update", "patch"]
  - apiGroups: ["extensions", "networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch"]

---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-role-binding
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: rbac
subjects:
  - kind: ServiceAccount
    name: test-service-account
    namespace: test-namespace
  - kind: User
    name: test-user
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: test-role
  apiGroup: rbac.authorization.k8s.io

---
# NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: networking
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: test-app
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: test-namespace
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: test-app
      ports:
        - protocol: TCP
          port: 8080
        - protocol: TCP
          port: 5432
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53

---
# Pod
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: pod
    app.kubernetes.io/version: "1.0.0"
    environment: development
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
spec:
  serviceAccountName: test-service-account
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  containers:
    - name: app-container
      image: nginx:1.24-alpine
      imagePullPolicy: IfNotPresent
      ports:
        - name: http
          containerPort: 80
          protocol: TCP
        - name: metrics
          containerPort: 8080
          protocol: TCP
      env:
        - name: NODE_ENV
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: NODE_ENV
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-password
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
      envFrom:
        - configMapRef:
            name: app-config
      resources:
        requests:
          memory: "64Mi"
          cpu: "250m"
        limits:
          memory: "128Mi"
          cpu: "500m"
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
          readOnly: true
        - name: data-volume
          mountPath: /var/data
        - name: tmp-volume
          mountPath: /tmp
      livenessProbe:
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
      readinessProbe:
        httpGet:
          path: /ready
          port: http
        initialDelaySeconds: 5
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
      startupProbe:
        httpGet:
          path: /startup
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 30
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
            - ALL
          add:
            - NET_BIND_SERVICE
    - name: sidecar-container
      image: busybox:1.35
      command: ["/bin/sh"]
      args: ["-c", "while true; do echo 'Sidecar running'; sleep 30; done"]
      resources:
        requests:
          memory: "32Mi"
          cpu: "100m"
        limits:
          memory: "64Mi"
          cpu: "200m"
  volumes:
    - name: config-volume
      configMap:
        name: app-config
        items:
          - key: app.properties
            path: app.properties
          - key: env.properties
            path: env.properties
    - name: data-volume
      persistentVolumeClaim:
        claimName: test-pvc
    - name: tmp-volume
      emptyDir:
        sizeLimit: 1Gi
  restartPolicy: Always
  terminationGracePeriodSeconds: 30
  dnsPolicy: ClusterFirst
  hostNetwork: false
  hostPID: false
  hostIPC: false

---
# Service
apiVersion: v1
kind: Service
metadata:
  name: test-service
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: nlb
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: test-app
  ports:
    - name: http
      port: 80
      targetPort: http
      protocol: TCP
    - name: metrics
      port: 8080
      targetPort: metrics
      protocol: TCP
  sessionAffinity: None

---
# Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: deployment
    app.kubernetes.io/version: "1.0.0"
  annotations:
    deployment.kubernetes.io/revision: "1"
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: test-app
      app.kubernetes.io/component: deployment
  template:
    metadata:
      labels:
        app.kubernetes.io/name: test-app
        app.kubernetes.io/component: deployment
        app.kubernetes.io/version: "1.0.0"
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: test-service-account
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 3000
        fsGroup: 2000
      containers:
        - name: app-container
          image: nginx:1.24-alpine
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          env:
            - name: NODE_ENV
              value: "production"
            - name: REPLICAS
              valueFrom:
                fieldRef:
                  fieldPath: status.replicas
          resources:
            requests:
              memory: "64Mi"
              cpu: "250m"
            limits:
              memory: "128Mi"
              cpu: "500m"
          volumeMounts:
            - name: config-volume
              mountPath: /etc/config
              readOnly: true
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
      volumes:
        - name: config-volume
          configMap:
            name: app-config
      restartPolicy: Always
      terminationGracePeriodSeconds: 30

---
# StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: test-statefulset
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: statefulset
spec:
  serviceName: test-statefulset-service
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: test-app
      app.kubernetes.io/component: statefulset
  template:
    metadata:
      labels:
        app.kubernetes.io/name: test-app
        app.kubernetes.io/component: statefulset
    spec:
      serviceAccountName: test-service-account
      containers:
        - name: app-container
          image: postgres:15-alpine
          ports:
            - name: postgres
              containerPort: 5432
              protocol: TCP
          env:
            - name: POSTGRES_DB
              value: "testdb"
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: database-username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: database-password
          volumeMounts:
            - name: data-volume
              mountPath: /var/lib/postgresql/data
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
  volumeClaimTemplates:
    - metadata:
        name: data-volume
        labels:
          app.kubernetes.io/name: test-app
          app.kubernetes.io/component: storage
      spec:
        accessModes:
          - ReadWriteOnce
        resources:
          requests:
            storage: 10Gi
        storageClassName: fast-ssd

---
# DaemonSet
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: test-daemonset
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: daemonset
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: test-app
      app.kubernetes.io/component: daemonset
  template:
    metadata:
      labels:
        app.kubernetes.io/name: test-app
        app.kubernetes.io/component: daemonset
    spec:
      serviceAccountName: test-service-account
      hostNetwork: true
      containers:
        - name: app-container
          image: fluent/fluent-bit:2.1
          ports:
            - name: metrics
              containerPort: 2020
              protocol: TCP
          volumeMounts:
            - name: varlog
              mountPath: /var/log
            - name: varlibdockercontainers
              mountPath: /var/lib/docker/containers
              readOnly: true
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
      volumes:
        - name: varlog
          hostPath:
            path: /var/log
        - name: varlibdockercontainers
          hostPath:
            path: /var/lib/docker/containers

---
# Job
apiVersion: batch/v1
kind: Job
metadata:
  name: test-job
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: job
spec:
  backoffLimit: 3
  activeDeadlineSeconds: 300
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      labels:
        app.kubernetes.io/name: test-app
        app.kubernetes.io/component: job
    spec:
      serviceAccountName: test-service-account
      restartPolicy: Never
      containers:
        - name: job-container
          image: busybox:1.35
          command: ["/bin/sh"]
          args: ["-c", "echo 'Job completed successfully'; sleep 10"]
          resources:
            requests:
              memory: "32Mi"
              cpu: "100m"
            limits:
              memory: "64Mi"
              cpu: "200m"

---
# CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: test-cronjob
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: cronjob
spec:
  schedule: "0 2 * * *"  # Run at 2 AM daily
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  startingDeadlineSeconds: 300
  jobTemplate:
    spec:
      backoffLimit: 2
      template:
        metadata:
          labels:
            app.kubernetes.io/name: test-app
            app.kubernetes.io/component: cronjob
        spec:
          serviceAccountName: test-service-account
          restartPolicy: OnFailure
          containers:
            - name: cronjob-container
              image: busybox:1.35
              command: ["/bin/sh"]
              args: ["-c", "echo 'CronJob executed at $(date)'; sleep 5"]
              resources:
                requests:
                  memory: "32Mi"
                  cpu: "100m"
                limits:
                  memory: "64Mi"
                  cpu: "200m"

---
# Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - test.example.com
        - api.test.example.com
      secretName: test-tls-secret
  rules:
    - host: test.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: test-service
                port:
                  number: 80
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: test-service
                port:
                  number: 8080
    - host: api.test.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: test-service
                port:
                  number: 8080

---
# HorizontalPodAutoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: test-hpa
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: test-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
        - type: Pods
          value: 2
          periodSeconds: 60
      selectPolicy: Max

---
# PodDisruptionBudget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: test-pdb
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: test-app
      app.kubernetes.io/component: deployment

---
# ServiceMonitor (Prometheus Operator)
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: test-servicemonitor
  namespace: test-namespace
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: monitoring
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: test-app
  endpoints:
    - port: metrics
      path: /metrics
      interval: 30s
      scrapeTimeout: 10s
      honorLabels: true
      relabelings:
        - sourceLabels: [__meta_kubernetes_pod_name]
          targetLabel: pod
        - sourceLabels: [__meta_kubernetes_pod_node_name]
          targetLabel: node

---
# CustomResourceDefinition (Example)
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: testresources.example.com
  labels:
    app.kubernetes.io/name: test-app
    app.kubernetes.io/component: crd
spec:
  group: example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                replicas:
                  type: integer
                  minimum: 1
                  maximum: 10
                image:
                  type: string
                resources:
                  type: object
                  properties:
                    requests:
                      type: object
                      properties:
                        memory:
                          type: string
                        cpu:
                          type: string
                    limits:
                      type: object
                      properties:
                        memory:
                          type: string
                        cpu:
                          type: string
            status:
              type: object
              properties:
                readyReplicas:
                  type: integer
                conditions:
                  type: array
                  items:
                    type: object
                    properties:
                      type:
                        type: string
                      status:
                        type: string
                      message:
                        type: string
      subresources:
        status: {}
  scope: Namespaced
  names:
    plural: testresources
    singular: testresource
    kind: TestResource
    shortNames:
      - tr
      - testres
