# LSP Configuration Rules for Cursor AI

This directory contains a modular LSP configuration for Neovim with comprehensive schema support.

## üèóÔ∏è Architecture Rules

### File Structure
- `init.lua` = Main entry point that orchestrates all servers
- `servers/[name].lua` = Individual server configurations (one per language)
- `docs/` = Documentation and AI agent instructions

### Modification Rules
1. **Adding new LSP server**: Create `servers/newserver.lua` + update `init.lua`
2. **Modifying existing server**: Edit only the relevant `servers/[name].lua`
3. **Schema changes**: Edit `jsonls.lua` or `yamlls.lua` schemas section
4. **Performance tuning**: Adjust `maxItemsComputed` and feature flags per server

## üîß Code Patterns

### New Server Template
```lua
-- servers/[language].lua
local M = {}

function M.setup(lspconfig, capabilities)
  lspconfig.[server_name].setup({
    capabilities = capabilities,
    settings = {
      [language] = {
        -- Language-specific settings
      },
    },
    filetypes = { "ext1", "ext2" },
    root_dir = require("lspconfig/util").root_pattern("pattern1", ".git"),
  })
end

return M
```

### Adding to init.lua
```lua
-- In config/lsp/init.lua
require("config.lsp.servers.[language]").setup(lspconfig, M.capabilities)
```

### Adding to Mason
```lua
-- In plugins/mason.lua ensure_installed list
"[server_name]", -- Add language server
```

## üìã Schema Management

### JSON Schema Addition
```lua
-- In servers/jsonls.lua
schemas = vim.tbl_extend("force", 
  require('schemastore').json.schemas(),
  {
    ["https://custom-schema.json"] = "pattern*.json"
  }
)
```

### YAML Schema Addition
```lua
-- In servers/yamlls.lua after SchemaStore loading
schemas["https://yaml-schema.yaml"] = {
  "pattern*.{yaml,yml}",
  "directory/**/*.{yaml,yml}"
}
```

### Kubernetes Pattern Addition
```lua
-- In servers/yamlls.lua static patterns section
"*newresource*.{yaml,yml}", "*nr*.{yaml,yml}",
```

## üéØ User Request Patterns

### "Add support for [language]"
1. Check if server exists in Mason registry
2. Create `servers/[language].lua` with appropriate settings
3. Add to `init.lua` setup calls
4. Add to Mason ensure_installed list
5. Test with sample file

### "My [filetype] files don't have autocompletion"
1. Check file pattern matching in relevant server config
2. Verify LSP attachment with `:LspInfo`
3. Check schema loading with `:messages`
4. Test with known working pattern

### "Performance is slow with large files"
1. Identify relevant server config file
2. Reduce `maxItemsComputed` setting
3. Disable expensive features like `colorDecorators`
4. Consider file-size-based adaptive configuration

## üö® Critical Rules

### DO NOT
- Modify multiple server configs for single language changes
- Create monolithic configurations in `init.lua`
- Break the modular structure
- Remove SchemaStore.nvim integration without replacement

### ALWAYS
- Test changes with provided test files in `test-schemas/`
- Update documentation when adding new servers
- Preserve existing schema functionality
- Follow the established naming patterns

## üîç Debugging Workflow

### User Reports Issue
1. **Identify scope**: Which language/server is affected?
2. **Locate config**: Find relevant `servers/[name].lua` file
3. **Check patterns**: Verify file naming matches schema patterns
4. **Test isolation**: Create minimal test case
5. **Apply fix**: Make targeted changes to specific server config

### Common Commands for Users
```vim
:LspInfo                 " Check attached servers
:messages               " Check for errors
:LspRestart             " Restart LSP servers
:lua print(vim.bo.filetype)  " Check file type detection
```

## üìä Schema Coverage Expectations

### JSON (100+ automatic via SchemaStore)
- package.json, tsconfig.json, eslint configs
- Build tools: webpack, vite, rollup
- Framework configs: Next.js, Nuxt, Angular

### YAML (100+ via SchemaStore + Kubernetes)
- CI/CD: GitHub Actions, GitLab CI, Azure Pipelines
- Infrastructure: Docker Compose, Kubernetes, Helm
- Documentation: OpenAPI, AsyncAPI

### Kubernetes (Comprehensive static + dynamic)
- All core resources with shortnames (pod/po, service/svc, etc.)
- Advanced workloads (HPA, VPA, PDB)
- Security resources (RBAC, PSP, Network Policies)
- Custom resources via kubernetes.nvim when cluster available

This modular approach ensures maintainability, performance, and extensibility while providing comprehensive language support.